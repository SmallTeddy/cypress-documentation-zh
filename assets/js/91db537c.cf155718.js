"use strict";(self.webpackChunkcypress_docusaurus_zh=self.webpackChunkcypress_docusaurus_zh||[]).push([[245],{9359:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var o=t(5893),s=t(1151);const a={title:"Angular Examples",sidebar_position:30,sidebar_label:"Examples"},i=void 0,c={id:"app/component-testing/angular/examples",title:"Angular Examples",description:"What you'll learn",source:"@site/docs/app/component-testing/angular/examples.mdx",sourceDirName:"app/component-testing/angular",slug:"/app/component-testing/angular/examples",permalink:"/app/component-testing/angular/examples",draft:!1,unlisted:!1,editUrl:"https://github.com/cypress-io/cypress-documentation/tree/main/docs/app/component-testing/angular/examples.mdx",tags:[],version:"current",lastUpdatedAt:1732009455,formattedLastUpdatedAt:"Nov 19, 2024",sidebarPosition:30,frontMatter:{title:"Angular Examples",sidebar_position:30,sidebar_label:"Examples"},sidebar:"app",previous:{title:"Overview",permalink:"/app/component-testing/angular/overview"},next:{title:"API",permalink:"/app/component-testing/angular/api"}},r={},l=[{value:"<Icon></Icon> What you&#39;ll learn",id:"What-youll-learn",level:5},{value:"Mounting Components",id:"Mounting-Components",level:2},{value:"Using <code>cy.mount()</code>",id:"Using-cymount",level:3},{value:"Passing Data to a Component",id:"Passing-Data-to-a-Component",level:3},{value:"Testing Event Handlers",id:"Testing-Event-Handlers",level:3},{value:"Imports/Declarations/Providers",id:"ImportsDeclarationsProviders",level:3},{value:"Using Standalone",id:"Using-Standalone",level:3},{value:"Using Angular Template Syntax",id:"Using-Angular-Template-Syntax",level:3},{value:"Accessing the Component Instance",id:"Accessing-the-Component-Instance",level:3},{value:"Using createOutputSpy()",id:"Using-createOutputSpy",level:3},{value:"Using autoSpyOutputs",id:"Using-autoSpyOutputs",level:3},{value:"Signals",id:"Signals",level:3},{value:"Testing Signals",id:"Testing-Signals",level:4},{value:"Inferred Generic Type",id:"Inferred-Generic-Type",level:5},{value:"Writable Signal",id:"Writable-Signal",level:5},{value:"Change Spies",id:"Change-Spies",level:5},{value:"Custom Mount Commands",id:"Custom-Mount-Commands",level:2},{value:"Customizing <code>cy.mount()</code>",id:"Customizing-cymount",level:3},{value:"Default Declarations, Providers, or Imports",id:"Default-Declarations-Providers-or-Imports",level:3},{value:"autoSpyOutputs",id:"autoSpyOutputs",level:3}];function p(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{Icon:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Icon",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.h5,{id:"What-youll-learn",children:[(0,o.jsx)(t,{name:"question-circle",color:"#4BBFD2"})," What you'll learn"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"How to mount an Angular component"}),"\n",(0,o.jsx)(n.li,{children:"How to pass data to an Angular component"}),"\n",(0,o.jsx)(n.li,{children:"How to test multiple scenarios of Angular components"}),"\n",(0,o.jsx)(n.li,{children:"How to test Angular signals"}),"\n",(0,o.jsxs)(n.li,{children:["How to customize the",(0,o.jsx)(n.code,{children:"cy.mount()"})," for Angular"]}),"\n"]})]}),"\n",(0,o.jsx)(n.h2,{id:"Mounting-Components",children:"Mounting Components"}),"\n",(0,o.jsxs)(n.h3,{id:"Using-cymount",children:["Using ",(0,o.jsx)(n.code,{children:"cy.mount()"})]}),"\n",(0,o.jsxs)(n.p,{children:["To mount a component with ",(0,o.jsx)(n.code,{children:"cy.mount()"}),", import the component and pass it to the\nmethod:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { StepperComponent } from './stepper.component'\n\nit('mounts', () => {\n  cy.mount(StepperComponent)\n})\n"})}),"\n",(0,o.jsx)(n.h3,{id:"Passing-Data-to-a-Component",children:"Passing Data to a Component"}),"\n",(0,o.jsxs)(n.p,{children:["You can pass inputs and outputs to a component by setting\n",(0,o.jsx)(n.a,{href:"/app/component-testing/angular/api#MountConfig",children:"componentProperties"}),"\nin the options:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"cy.mount(StepperComponent, {\n  componentProperties: {\n    count: 100,\n    change: new EventEmitter(),\n  },\n})\n"})}),"\n",(0,o.jsx)(n.h3,{id:"Testing-Event-Handlers",children:"Testing Event Handlers"}),"\n",(0,o.jsxs)(n.p,{children:["Pass a Cypress ",(0,o.jsx)(n.a,{href:"/app/guides/stubs-spies-and-clocks#Spies",children:"spy"})," to an event\nprop and validate it was called:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"it('clicking + fires a change event with the incremented value', () => {\n  cy.mount(StepperComponent, {\n    componentProperties: {\n      change: createOutputSpy('changeSpy'),\n    },\n  })\n  cy.get('[data-cy=increment]').click()\n  cy.get('@changeSpy').should('have.been.calledWith', 1)\n})\n"})}),"\n",(0,o.jsx)(n.h3,{id:"ImportsDeclarationsProviders",children:"Imports/Declarations/Providers"}),"\n",(0,o.jsxs)(n.p,{children:["If you need to set up any additional ",(0,o.jsx)(n.code,{children:"imports"}),", ",(0,o.jsx)(n.code,{children:"declarations"}),", or ",(0,o.jsx)(n.code,{children:"providers"}),"\nfor your component to mount successfully, you can set them in the options\n(similar to setting them up in ",(0,o.jsx)(n.code,{children:"ngModule"})," in a app):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"cy.mount(ComponentThatFetchesData, {\n  imports: [HttpClientModule],\n  declarations: [ButtonComponent],\n  providers: [DataService],\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See\n",(0,o.jsx)(n.a,{href:"/app/component-testing/angular/examples#Default-Declarations-Providers-or-Imports",children:"Default Declarations, Providers, or Imports"}),"\nto set up common options in a custom ",(0,o.jsx)(n.code,{children:"cy.mount()"})," command to avoid having to\nrepeat this boilerplate for each test."]}),"\n",(0,o.jsx)(n.h3,{id:"Using-Standalone",children:"Using Standalone"}),"\n",(0,o.jsxs)(n.p,{children:["Not only are ",(0,o.jsx)(n.a,{href:"https://angular.io/guide/standalone-components",children:"Standalone Components"})," supported, they are the simplest components to write tests for.\nStandalone Components provide the Angular compiler with everything it needs to compile through its ",(0,o.jsx)(n.a,{href:"https://angular.io/api/core/Component",children:(0,o.jsx)(n.code,{children:"@Component()"})})," decorator.\nThis means that in most cases a Standalone Component can be mounted without ever providing any ",(0,o.jsx)(n.code,{children:"imports"}),", ",(0,o.jsx)(n.code,{children:"decorators"}),", or ",(0,o.jsx)(n.code,{children:"providers"}),". Mounting then becomes as simple as:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"cy.mount(MyStandaloneComponent)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"Using-Angular-Template-Syntax",children:"Using Angular Template Syntax"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"cy.mount()"})," method also supports the Angular template syntax when mounting\na component. Some developers might prefer this approach to the object based\nmount style:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'cy.mount(`<app-stepper [count]="100"></app-stepper>`, {\n  declarations: [StepperComponent],\n})\n'})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"When using template syntax, the component needs to added to the declarations\nin the options parameter."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Using with event emitter spy:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"cy.mount('<app-button (click)=\"onClick.emit($event)\">Click me</app-button>', {\n  declarations: [ButtonComponent]\n  componentProperties: {\n    onClick: createOutputSpy('onClickSpy'),\n  },\n})\ncy.get('button').click();\ncy.get('@onClickSpy').should('have.been.called');\n"})}),"\n",(0,o.jsx)(n.h3,{id:"Accessing-the-Component-Instance",children:"Accessing the Component Instance"}),"\n",(0,o.jsxs)(n.p,{children:["There might be times when you might want to access the component instance\ndirectly in your tests. To do so, use ",(0,o.jsx)(n.code,{children:".then()"}),", which enables us to work with\nthe subject that was yielded from the ",(0,o.jsx)(n.code,{children:"cy.mount()"})," command. In this case, mount\nyields an object that contains the rendered component and the fixture."]}),"\n",(0,o.jsxs)(n.p,{children:["In the below example, we use the component to spy directly on the ",(0,o.jsx)(n.code,{children:"change"})," event\nemitter."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"it('clicking + fires a change event with the incremented value', () => {\n  cy.mount(\n    '<app-stepper count=\"100\" (change)=\"change.emit($event)\"></app-stepper>',\n    {\n      componentProperties: { change: new EventEmitter() },\n      declarations: [StepperComponent],\n    }\n  ).then((wrapper) => {\n    console.log({ wrapper })\n    cy.spy(wrapper.component.change, 'emit').as('changeSpy')\n    return cy.wrap(wrapper).as('angular')\n  })\n  cy.get(incrementSelector).click()\n  cy.get('@changeSpy').should('have.been.calledWith', 101)\n})\n"})}),"\n",(0,o.jsx)(n.h3,{id:"Using-createOutputSpy",children:"Using createOutputSpy()"}),"\n",(0,o.jsxs)(n.p,{children:["To make spying on event emitters easier, there is a utility function called\n",(0,o.jsx)(n.code,{children:"createOutputSpy()"})," which can be used to automatically create an ",(0,o.jsx)(n.code,{children:"EventEmitter"}),"\nand setup the spy on it's ",(0,o.jsx)(n.code,{children:".emit()"})," method. It can be used like the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { createOutputSpy } from 'cypress/angular'\n\nit('clicking + fires a change event with the incremented value', () => {\n  // Arrange\n  cy.mount('<app-stepper (change)=\"change.emit($event)\"></app-stepper>', {\n    declarations: [StepperComponent],\n    componentProperties: {\n      change: createOutputSpy<boolean>('changeSpy'),\n    },\n  })\n  cy.get(incrementSelector).click()\n  cy.get('@changeSpy').should('have.been.called')\n})\n"})}),"\n",(0,o.jsx)(n.h3,{id:"Using-autoSpyOutputs",children:"Using autoSpyOutputs"}),"\n",(0,o.jsxs)(n.p,{children:["You might find yourself repeatedly creating a ",(0,o.jsx)(n.code,{children:"cy.spy()"})," for each of your\ncomponent outputs. Because of this, we created an easy mechanism to handle this\nfor you. This feature can be turned on by passing the ",(0,o.jsx)(n.code,{children:"autoSpyOutputs"})," flag into\n",(0,o.jsx)(n.code,{children:"MountConfig"}),". After the component has been mounted you can then access each of\nthe generated spies using the ",(0,o.jsx)(n.code,{children:"@Output()"})," property name + ",(0,o.jsx)(n.code,{children:"Spy"}),". So our ",(0,o.jsx)(n.code,{children:"change"}),"\nproperty can be accessed via its alias of ",(0,o.jsx)(n.code,{children:"cy.get('@changeSpy')"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"it('clicking + fires a change event with the incremented value', () => {\n  cy.mount(StepperComponent, {\n    autoSpyOutputs: true,\n    componentProperties: {\n      count: 100,\n    },\n  })\n  cy.get(incrementSelector).click()\n  cy.get('@changeSpy').should('have.been.calledWith', 101)\n})\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"autoSpyOutput"})," flag only works when passing in a component to the mount\nfunction. It currently does not work with the template syntax."]})}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"autoSpyOutput"})," is an ",(0,o.jsx)(n.strong,{children:"experimental feature"})," and could be removed or changed\nin the future"]})}),"\n",(0,o.jsx)(n.h3,{id:"Signals",children:"Signals"}),"\n",(0,o.jsxs)(n.p,{children:["With the releases of Angular versions ",(0,o.jsx)(n.a,{href:"https://github.com/angular/angular/blob/main/CHANGELOG.md#1710-2024-01-17",children:"17.1"})," and ",(0,o.jsx)(n.a,{href:"https://github.com/angular/angular/blob/main/CHANGELOG.md#1720-2024-02-14",children:"17.2"}),", ",(0,o.jsx)(n.a,{href:"https://github.com/angular/angular/pull/53521",children:"input"})," and ",(0,o.jsx)(n.a,{href:"https://github.com/angular/angular/pull/54252",children:"model"})," signals were introduced into the ",(0,o.jsx)(n.code,{children:"@angular/core"})," API.\nSince signals introduced new methods and types to the core API, Cypress introduced a new test harness, ",(0,o.jsx)(n.code,{children:"@cypress/angular-signals"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Though basic signals were introduced in Angular ",(0,o.jsx)(n.code,{children:"16"}),", this testing harness requires Angular ",(0,o.jsx)(n.code,{children:"17.2"})," and above."]}),"\n",(0,o.jsxs)(n.p,{children:["For the below examples, we'll be working with a very simple component called ",(0,o.jsx)(n.code,{children:"TestComponent"}),", which looks something like shown below:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// app/components/test-component.component.ts\nimport { Component, input, model } from '@angular/core'\n\n@Component({\n  selector: 'test-component',\n  templateUrl: './test-component.component.html',\n  standalone: true,\n})\nexport class TestComponent {\n  title = input.required<string>()\n  count = model<number>(1)\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'\x3c!-- app/components/test-component.component.html --\x3e\n<p data-cy="test-component-title-display">{{ title() }}</p>\n<p data-cy="test-component-count-display">{{ count() }}</p>\n<button data-cy="test-component-count-incr" (click)="count.set(count() + 1)">\n  Increase\n</button>\n<button data-cy="test-component-count-decr" (click)="count.set(count() - 1)">\n  Decrease\n</button>\n'})}),"\n",(0,o.jsx)(n.h4,{id:"Testing-Signals",children:"Testing Signals"}),"\n",(0,o.jsx)(n.p,{children:"There are two ways to test signals within Cypress Component Testing:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#Inferred-Generic-Type",children:"Inferred Generic Type"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#Writable-Signal",children:"Writable Signal"})}),"\n"]}),"\n",(0,o.jsx)(n.h5,{id:"Inferred-Generic-Type",children:"Inferred Generic Type"}),"\n",(0,o.jsxs)(n.p,{children:["In the example below, the ",(0,o.jsx)(n.code,{children:"title"})," prop being passed into our ",(0,o.jsx)(n.code,{children:"TestComponent"})," is a ",(0,o.jsx)(n.code,{children:"string"}),". A ",(0,o.jsx)(n.code,{children:"string"})," is the generic type of our ",(0,o.jsx)(n.code,{children:"input()"})," signal we defined in our ",(0,o.jsx)(n.code,{children:"TestComponent"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"let titleProp = 'Test Component'\ncy.mount(TestComponent, {\n  componentProperties: {\n    title: titleProp,\n  },\n})\n\ncy.get('[data-cy=\"test-component-title-display\"]').should(\n  'have.text',\n  'Test Component'\n)\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["Under the hood, Cypress wraps the generic value in a writable ",(0,o.jsx)(n.code,{children:"signal()"})," and merges it into the prop. In other words, the ",(0,o.jsx)(n.code,{children:"@cypress/angular-signals"})," test harness in this example is really:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"cy.mount(TestComponent, {\n  componentProperties: {\n    title: signal('Test Component'),\n  },\n})\n"})})]}),"\n",(0,o.jsxs)(n.p,{children:["This works for any signal. Shown below is an example of testing a ",(0,o.jsx)(n.code,{children:"model()"})," signal with a generic type ",(0,o.jsx)(n.code,{children:"number"})," as seen in our ",(0,o.jsx)(n.code,{children:"TestComponent"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"cy.mount(TestComponent, {\n  componentProperties: {\n    title: 'Test Component',\n    count: 3,\n  },\n})\n\ncy.get('[data-cy=\"test-component-count-display\"]').should('have.text', '3')\n"})}),"\n",(0,o.jsx)(n.h5,{id:"Writable-Signal",children:"Writable Signal"}),"\n",(0,o.jsxs)(n.p,{children:["Inferred generic types work very well for most test cases. However, they don't allow us to update the prop in the component after the prop is passed in. For this use case, we need to use a writable ",(0,o.jsx)(n.code,{children:"signal()"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["This allows us to test our one-way data binding for our ",(0,o.jsx)(n.code,{children:"input()"})," signals."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const myTitlePropAsSignal = signal('Test Component')\ncy.mount(TestComponent, {\n  componentProperties: {\n    title: myTitlePropAsSignal,\n  },\n})\n\ncy.get('[data-cy=\"test-component-title-display\"]').should(\n  'have.text',\n  'Test Component'\n)\ncy.then(() => {\n  // now set the input() through a signal to update the one-way binding\n  myTitlePropAsSignal.set('FooBar')\n})\n\ncy.get('[data-cy=\"test-component-title-display\"]').should('have.text', 'FooBar')\n"})}),"\n",(0,o.jsxs)(n.p,{children:["And our two-way data binding for our ",(0,o.jsx)(n.code,{children:"model()"})," signals."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"let count = signal(5)\ncy.mount(TestComponent, {\n  componentProperties: {\n    title: 'Test Component',\n    count,\n  },\n})\n\ncy.then(() => {\n  // now set the model() through a signal to update the binding in the component\n  count.set(8)\n})\n\ncy.get('[data-cy=\"test-component-count-display\"]').should('have.text', '8')\n\n// some action occurs that changes the count to 9 inside the component, which updates the binding in our test\ncy.get('[data-cy=\"test-component-count-incr\"]').click()\ncy.get('[data-cy=\"test-component-count-display\"]').should('have.text', '9')\ncy.then(() => {\n  expect(count()).to.equal(9)\n})\n"})}),"\n",(0,o.jsx)(n.h5,{id:"Change-Spies",children:"Change Spies"}),"\n",(0,o.jsxs)(n.p,{children:["Cypress doesn't propagate changes via spy from ",(0,o.jsx)(n.code,{children:"input()"})," signals."]}),"\n",(0,o.jsxs)(n.p,{children:["For writable signals, such as ",(0,o.jsx)(n.code,{children:"model()"}),"s or ",(0,o.jsx)(n.code,{children:"signal()"}),"s, Cypress ",(0,o.jsx)(n.strong,{children:"will"})," propagate changes if an output spy is created with the prop's name suffixed with ",(0,o.jsx)(n.code,{children:"Change"}),". In the example below,\n",(0,o.jsx)(n.code,{children:"countChange"})," will spy on changes to the ",(0,o.jsx)(n.code,{children:"count"})," signal."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"cy.mount(TestComponent, {\n  componentProperties: {\n    title: 'Test Component',\n    count: 4,\n    // @ts-expect-error\n    countChange: createOutputSpy('countChange'),\n  },\n})\n\n// some action occurs that changes the count\ncy.get('[data-cy=\"test-component-count-incr\"]').click()\n\ncy.get('@countChange').should('have.been.called')\n"})}),"\n",(0,o.jsxs)(n.p,{children:["These spies can automatically be created if ",(0,o.jsx)(n.code,{children:"autoSpyOutputs: true"})," is configured. The suffix in this case will be ",(0,o.jsx)(n.code,{children:"ChangeSpy"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"Custom-Mount-Commands",children:"Custom Mount Commands"}),"\n",(0,o.jsxs)(n.h3,{id:"Customizing-cymount",children:["Customizing ",(0,o.jsx)(n.code,{children:"cy.mount()"})]}),"\n",(0,o.jsxs)(n.p,{children:["By default, ",(0,o.jsx)(n.code,{children:"cy.mount()"})," is a simple passthrough to ",(0,o.jsx)(n.code,{children:"mount()"}),", however, you can\ncustomize ",(0,o.jsx)(n.code,{children:"cy.mount()"})," to fit your needs. For instance, you may find yourself\ndoing repetitive work during mounting. In order to reduce boilerplate you may\nfind it useful to create a custom mount command."]}),"\n",(0,o.jsx)(n.h3,{id:"Default-Declarations-Providers-or-Imports",children:"Default Declarations, Providers, or Imports"}),"\n",(0,o.jsxs)(n.p,{children:["If you find yourself registering a bunch of declarations, providers, or imports\nin your individual tests, we recommend doing them all within a custom\n",(0,o.jsx)(n.code,{children:"cy.mount()"})," command. The overhead is usually minimal for all your tests and it\nhelps keep your spec code clean."]}),"\n",(0,o.jsx)(n.p,{children:"Below is a sample that registers several default component declarations while\nstill allowing additional ones to be passed in via the config param. The same\npattern can also be applied to providers and module imports."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"title=support/component.ts",children:"import { Type } from '@angular/core'\nimport { mount, MountConfig } from 'cypress/angular'\nimport { ButtonComponent } from 'src/app/button/button.component'\nimport { CardComponent } from 'src/app/card/card.component'\n\ndeclare global {\n  namespace Cypress {\n    interface Chainable {\n      mount: typeof customMount\n    }\n  }\n}\n\nconst declarations = [ButtonComponent, CardComponent]\n\nfunction customMount<T>(component: string | Type<T>, config?: MountConfig<T>) {\n  if (!config) {\n    config = { declarations }\n  } else {\n    config.declarations = [...(config?.declarations || []), ...declarations]\n  }\n  return mount<T>(component, config)\n}\n\nCypress.Commands.add('mount', customMount)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This custom mount command will allow you to skip manually passing in the\n",(0,o.jsx)(n.code,{children:"ButtonComponent"})," and ",(0,o.jsx)(n.code,{children:"CardComponent"})," as declarations into each ",(0,o.jsx)(n.code,{children:"cy.mount()"}),"\ncall."]}),"\n",(0,o.jsx)(n.h3,{id:"autoSpyOutputs",children:"autoSpyOutputs"}),"\n",(0,o.jsxs)(n.p,{children:["Here is an example of defaulting ",(0,o.jsx)(n.code,{children:"autoSpyOutputs"})," for every mounted component:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:"title=support/component.ts",children:"declare global {\n  namespace Cypress {\n    interface Chainable {\n      mount: typeof mount\n    }\n  }\n}\n\nCypress.Commands.add(\n  'mount',\n  (component: Type<unknown> | string, config: MountConfig<T>) => {\n    return mount(component, {\n      ...config,\n      autoSpyOutputs: true,\n    })\n  }\n)\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"autoSpyOutput"})," flag only works when passing in a component to the mount\nfunction. It currently does not work with the template syntax."]})})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>i});var o=t(7294);const s={},a=o.createContext(s);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);